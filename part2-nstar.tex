\part{The back end}\label{part:nstar}


\chapter{Introduction}\label{chap:nstar-abstract}

Assembly languages are the lowest level of humanly-possible programming there exists nowadays. They were used back in the days for very performance-critical tasks, or even just for fun, as there weren't many other programming languages available. Nowadays, with all the existing ones, most people have never used any assembly language.

Despite their apparent simplicity, and the small amount of work you need to put into creating assembly languages, those are in fact very hard to use. At that low level, there is no such thing as Java's exceptions keeping you from doing dumb things, Rust's linear types keeping you from leaking memory nor even Garbage Collectors. The nice things preventing you from having segfaults simply do not exist, and you are expected to either provide all those things yourself (creating a language runtime) or be very careful about what you are doing each time you write a single instruction (even a simple \texttt{mov} can have undesirable side-effects).

Doing dumb things is something that we must prevent directly when using the language. That way, we do not need to rely on external verification tools or debuggers, trying to know why a program segfaults at a specific point.
This is where a type system can become handy. Typed assembly languages are assembly languages augmented with simple yet powerful type system. Among the most famous typed assembly languages are TALx86~\cite{TALx86} and DTAL~\cite{DTAL}.

TALx86 is basically NASM with a type system, targetting only the x86 architecture. DTAL is much more complicated and embeds a completely dependent type system.

\vspace{\baselineskip}

N*'s goal is to assist users with a simple but powerful type system, as well as other features like what I call ``branch-checking'' which prevents from leaking the control flow of the program, and thus makes a part of the type-checking process meaningful.
But before even being a usable programming language, N* aims at being a compiler backend (much like for example LLVM), and is used as is in the Zilch project. Differences with other compiler backends are mostly the type-system, allowing the compilation of Zilch source code into type-safe instructions.

\vspace{\baselineskip}

Because N* supports compiling to multiple architectures, using different grammars, describing N* will at first be platform-agnostic, treating common aspects between all CPU architectures, and then will be divided into multiple categories, explaining in more details some features on a per-architecture basis\footnote{Note that the target executable format (ELF, PE, \ldots) is also considered as an architecture-specific thing, but should not influence N* much.}.

\chapter{Non platform-specific features}\label{chap:nstar-common}

\section{Types}\label{sec:nstar-common-ts}

One of the differences between classical assembly languages and N* is its type system.
Compared to other higher level programming languages like Java, C++, etc, N* has a very simple yet powerful and expressive enough type system.

In programming, types are used mostly to prove at compile-time that a given program should behave well if it type-checks. While this works for more elaborated programming languages like Haskell, Idris, etc, most type systems aren't expressive enough to absolutely guarantee that everything will work at run-time (in fact, there is no possible way of doing this, because for example a memory allocation may fail, and this cannot be endorsed at compile-time). However, we can try to guarantee as much as possible.

N* doesn't try to solve this issue, because it would be really hard to target a dependently typed assembly language from a non-dependently typed programming language. But where all used assembly languages do not even consider types (only numbers, in fact), N* embeds a powerful type system used to remove the possibility of bugs (like incorrect structure addresses passed as a parameter function, or incoherent types in some instructions).

\subsection{Kinds}\label{subsec:nstar-common-ts-kinds}

Kinds (also known as types of types) mainly serve the purpose of indicating type sizes.
There are three type of kinds in N*:
\begin{itemize}
  \item Stack kind, denotating stack-like types, which can be safely offsetted
  \item Kinds whose size is abstracted away, useful to ask for any sized type
  \item Kinds whose size is already known
\end{itemize}
The grammar is given in Figure~\ref{fig:nstar-common-ts-kinds-syntax}.

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-kinds-syntax}
  }
  \caption{Grammar for kinds.}
  \label{fig:nstar-common-ts-kinds-syntax}
\end{figure}

\subsection{Integer types}\label{subsec:nstar-common-ts-integer}

Numbers are the building block of any assembly language. Most of data manipulated is manipulated as numbers, e.g. addresses, characters, strings, enumerations, etc.
This is not the case in N*, where ``integer''  only really means ``number''.
The syntax for the types of integers is given in Figure~\ref{fig:nstar-common-ts-integer-syntax}.

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-integers-types-syntax}
  }
  \caption{Grammar for integer types.}
  \label{fig:nstar-common-ts-integer-syntax}
\end{figure}

Integers have two varying parameters: their sign and sizes.
According to the sign (i.e. signed or unsigned), some operations may not perform the same (for example \texttt{mul} does not behave the same).
The size is nothing more than the number of bits occupied by the integer (in N*, those are restricted to multiples of $8$ smaller or equal to $64$).
Most operations should perform the same no matter the integer size, however it is recommended to search in the target architecture manual for further reference.

Kinds of integers are written under the form of inference rules in Figure~\ref{fig:nstar-common-ts-integer-kindrules}.

\begin{figure}[htb]
  \centering

  \begin{prooftree}
    \Infer0{$u64 : T8$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Infer0{$s64 : T8$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Infer0{$u32 : T4$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Infer0{$s32 : T4$}
  \end{prooftree}
  \\\vspace{\baselineskip}
  \begin{prooftree}
    \Infer0{$u16 : T2$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Infer0{$s16 : T2$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Infer0{$u8 : T1$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Infer0{$s8 : T1$}
  \end{prooftree}

  \caption{Kind inference rules for integers.}
  \label{fig:nstar-common-ts-integer-kindrules}
\end{figure}

\subsection{Other atomic types}\label{subsec:nstar-common-ts-otheratomic}

There are two other atomic types that we did not talk about, but refered to in the introduction of the type system: characters and pointers. Their respective syntax is given in Figure~\ref{fig:nstar-common-ts-atomic-syntax}.

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-ptr-type-syntax}
  } \\
  \scalebox{.5}{
    \includegraphics{nstar-char-type-syntax}
  }
  \caption{Grammar for character and pointer types}
  \label{fig:nstar-common-ts-atomic-syntax}
\end{figure}

In all assembly languages, characters are merely syntactic sugar for their ASCII code. This is how their are put in the machine code anyway, so it is not a huge problem (it might even not be at all).

Pointers, on the other hand, are unabstracted memory addresses.
In N*, there are two types of pointers: data pointers and stack pointers.
Stack pointers are covered in Subsection~\ref{subsec:nstar-common-ts-stack}~``\nameref{subsec:nstar-common-ts-stack}''.
Data pointers simply represent an address where we know (or not, see the Subsection~\ref{subsec:nstar-common-unsafe-derefliteraladdr}~``\nameref{subsec:nstar-common-unsafe-derefliteraladdr}'') that there is a value of the given pointed type.

Kind inference is given in Figure~\ref{fig:nstar-common-ts-atomic-kindrules}.

They support two common operations: offsetting (see the Subsection~\ref{subsec:nstar-common-unsafe-ptroffset}~``\nameref{subsec:nstar-common-unsafe-ptroffset}'') and dereferencing (taking the value pointed by the pointer).
Dereferencing is considered a safe operation, unless trying to on a literal address.
There is no notion of ``null'' pointers, like \texttt{NULL} in C.
However, it is possible to use the literal \texttt{\$0} (which represents a pointer to the address $0$).

\begin{figure}[htb]
  \centering
  \begin{prooftree}
    \Infer0{$char : T1$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Hypo{$t : Ta$}
    \Infer1[64-bits pointers]{$*t : T8$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Hypo{$t : Ta$}
    \Infer1[32-bits pointers]{$*t : T4$}
  \end{prooftree}

  \caption{Kind inference rules for other atomic types.}
  \label{fig:nstar-common-ts-atomic-kindrules}
\end{figure}

\subsection{Context types}\label{subsec:nstar-common-ts-records}

Record types (or contexts) are mappings from registers to types.
They are used to indicate that a register is bound to a value of a given type at a certain point in the program.
The grammar is described in Figure~\ref{fig:nstar-common-ts-records-syntax}.

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-records-syntax}
  }
  \caption{Grammar for context types.}
  \label{fig:nstar-common-ts-records-syntax}
\end{figure}

Context types are used to represent data contexts where any mapping is some sort of a proof that some data of some type is accessible through some register.

\vspace{\baselineskip}

\textbf{Note:} In the context of label types, a context type can be augmented by a \texttt{forall} generic type variable binder.
The grammar is described in Figure~\ref{fig:nstar-common-ts-label-types-syntax}.
The type variable binder is used to abstract away some details of the type through an opaque variable specialized at the call site.

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-label-types-syntax}
  }
  \caption{Grammar for label context types.}
  \label{fig:nstar-common-ts-label-types-syntax}
\end{figure}

The example code given in Listing~\ref{lst:nstar-common-ts-records-stackmask} shows a use for type variables.
The stack is abstracted away, meaning that we can call this function from anywhere, given any stack (as long as it is \texttt{call}ed, or \texttt{jmp}ed to from a \texttt{call}ed function).
The type variable \texttt{s} is specialized at the call site.

\begin{listing}[htb]
  \centering
  \begin{minipage}{0.90\textwidth}
    \begin{minted}[]{\nstarlexer}
      label: forall (s: Ts). { %rsp: sptr *{ %rsp: sptr s }::s }
          ret
    \end{minted}
  \end{minipage}
  \caption{Stack masking using a type variable binder.}
  \label{lst:nstar-common-ts-records-stackmask}
\end{listing}

\subsection{Stack types}\label{subsec:nstar-common-ts-stack}

There are mainly two stack types in N*: the stack pointer \texttt{sptr} and the stack constructor \texttt{::}.
Note that there is no ``empty stack'' type as would be the case with e.g. lists in Haskell.
The reason is that it forces the developer to abstract the stack to be able to have a ``stack tail'' (the part of the stack on the right of the stack constructor \texttt{::}) at some point.\footnote{It also serves the purpose to ensure that we cannot construct a stack from nothing, and that it should always be given to us, to e.g. the \texttt{main} function.}
An example is given in Listing~\ref{lst:nstar-common-ts-records-stackmask}.

The grammar for stack types is given in Figure~\ref{fig:nstar-common-ts-stack-types-syntax}.

Inference rules for kinds of stack types are written in Figure~\ref{fig:nstar-common-ts-stack-types-kindrules}

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-stack-pointer-syntax}
  }
  \\
  \scalebox{.5}{
    \includegraphics{nstar-stack-cons-syntax}
  }
  \caption{Grammar for stack types.}
  \label{fig:nstar-common-ts-stack-types-syntax}
\end{figure}

\begin{figure}[htb]
  \centering

  \begin{prooftree}
    \Hypo{$s : Ts$}
    \Infer1[32-bits pointers]{$sptr s : T4$}
  \end{prooftree}
  \hspace{3em}
  \begin{prooftree}
    \Hypo{$s : Ts$}
    \Infer1[64-bits pointers]{$sptr s : T8$}
  \end{prooftree}
  \\\vspace{\baselineskip}
  \begin{prooftree}
    \Hypo{$n : $\mathbb{N}$ $}
    \Hypo{$t : Tn$}
    \Hypo{$s : Ts$}
    \Infer3{$t :: s : Ts$}
  \end{prooftree}

  \caption{Kind inference rules for stack types}
  \label{fig:nstar-common-ts-stack-types-kindrules}
\end{figure}

\subsection{Structure types}\label{subsec:nstar-common-ts-structs}

Structure types are packed sets of unnamed types (compared to context types, each field does not have a name, only a type) that can be indexed from a pointer only to a full field (so if you have two \texttt{u64}s, you can only offset to $0$ and $8$, respectively for the first and second field).

Grammar is described in Figure~\ref{fig:nstar-common-ts-structs-syntax} and kind inference rules are given in Figure~\ref{fig:nstar-common-ts-structs-kindrules}.

Structures take as much space as all their fields, thus can mainly be put on the stack (unless being less than 8 bytes, which is the upper limit for register sizes in current architectures).

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-struct-types-syntax}
  }

  \caption{Grammar for structure types.}
  \label{fig:nstar-common-ts-structs-syntax}
\end{figure}

\begin{figure}[htb]
  \centering
  \begin{prooftree}
    \Hypo{$n$_0$, n$_1$, $\ldots$, n$_p$ : $\mathbb{N}}
    \Hypo{$t$_0$ : Tn$_0$, t$_1$ : Tn$_1$, $\ldots$, t$_p$ : Tn$_p}
    \Hypo{$m = $\sum_{i = 0}^{p}{n_i}}
    \Infer3{$(t$_0$, t$_1$, $\ldots$, t$_p$) : Tm$}
  \end{prooftree}

  \caption{Kind inference rule for structures.}
  \label{fig:nstar-common-ts-structs-kindrules}
\end{figure}

\subsection{Union types}\label{subsec:nstar-common-ts-unions}

Union types simply are overlapping data bits, which can be given meaning depending on what type you decide to access.
Grammar for union types is given in Figure~\ref{fig:nstar-common-ts-unions-syntax}.

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-union-types-syntax}
  }

  \caption{Grammar for union types.}
  \label{fig:nstar-common-ts-unions-syntax}
\end{figure}

Unions are sized depending on the types they unite: their sizes will be the maximum of all the sizes of all the components.
This is more clear in the kind inference rule given in Figure~\ref{fig:nstar-common-ts-unions-kindrules}.

\begin{figure}[htb]
  \centering

  \begin{prooftree}
    \Hypo{$n$_0$, n$_1$, $\ldots$, n$_p$ : $\mathbb{N}}
    \Hypo{$t$_0$ : n$_0$, t$_1$ : n$_1$, $\ldots$, t$_p$ : n$_p}
    \Hypo{$m = $\max_{i = 0}^{p}{n_i}}
    \Infer3{$<t$_0$, t$_1$, $\ldots$, t$_p$> : Tm$}
  \end{prooftree}

  \caption{Kind inference rules for union types.}
  \label{fig:nstar-common-ts-unions-kindrules}
\end{figure}

Note that unlike structure types, you will most likely be storing union types in registers, unless working with very big unions.
Also, accessing a union's field is considered an unsafe operation, but this will be more detailed in another section on expressions.

\section{File sections}\label{sec:nstar-common-sections}

Sections in N* serve the exact same purpose as in other assembly languages. They divide a file into multiple parts depending on what the semantics of the current section is supposed to be (code, data, etc).
Section names obviously differ from one target format to another. As an example, the ``\texttt{.rela.dyn}'' section from the ELF format may not exist in the PE format.

N* tries to unify target formats section names (simplifying targetting N* as a compiler backend) by having a fixed set of section names, all with different meanings. While you can put anything anywhere in classical assembly languages, this is not the case in N*.

Sections in N* can be named ``\texttt{data}'', ``\texttt{code}'' or ``\texttt{rodata}''. Each of them has defined semantics as described below.

\subsection{The \texttt{code} section}\label{subsec:nstar-common-sections-code}

The \texttt{code} section is the section containing all executable instructions (basically, as the name implies, code). Its syntax is defined in Figure~\ref{fig:nstar-common-sections-code-grammar}.

Each label is assigned a type, describing the context needed to branch to it.
If a label has the type \texttt{\{reg:s64\}} then there needs to be the register \texttt{reg} bound to a value of type \texttt{s64} in the current context, in order to branch to it.
However, some restrictions apply to labels in order to make the type-checking meaningful (or at least handle some aspects that cannot be handled with types only). See more about that in Section~\ref{sec:nstar-common-bs}~``\nameref{sec:nstar-common-bs}''.

\begin{figure}[htb]
  \centering
  \scalebox{.5}{
    \includegraphics{nstar-code-section-1}
  }
  \\
  \scalebox{.5}{
    \includegraphics{nstar-code-section-2}
  }

  \caption{Grammar for \texttt{code} sections.}
  \label{fig:nstar-common-sections-code-grammar}
\end{figure}

Every assembly instruction makes the current context vary in some way, either by binding registers, forgetting about some bindings, changing register types, or some other way. The current context is just a record keeping track of the currently bound registers, along with the data type they contain. More on that in sections about instructions\footnote{Instructions are platform-specific, that's why we don't talk about them here.}.

\subsection{The \texttt{data} and \texttt{rodata} sections}\label{subsec:nstar-common-sections-data}

\section{Restrictions applied to branching}\label{sec:nstar-common-bs}

Branching ((un-)conditional jumps, calls, etc) is restricted in N* in order to prevent stack leaks, unknown caller address return or even missing return values.
It also is restricted not to integrate some sort of scoping, which would add some (mostly useless) complexity when using/generating N*.

\subsection{Returning to a known code-space address}\label{subsec:nstar-common-bs-ret}

Because the stack is given a type in N*, we can use it to make sure that we are returning to a code-space address.
When we \texttt{call} a label, we are pushing the current instruction pointer on top of the stack (the stack pointer is \texttt{\%rip} on x86/x64, \texttt{\$ip} on MIPS, etc) before jumping to the callee address.

Because of that, the type given to the stack for the context of a label contains at least a pointer to some context (\texttt{*\{ binds\ldots\ \}}) on the very top of it (unless this label is never meant to be \texttt{call}ed but rather \texttt{jmp}ed to).
This is later used by \texttt{ret} in order to determine that returning from this function can be done safely, and \textit{should}\footnote{It should return to a valid address, but this cannot be checked nor endorsed when using, for example, the foreign function interface or when creating a \texttt{main} function.} return to a valid code-space address.
If any other data-type is present on top of the stack (an integer, a pointer to something else than a context, a stack pointer, a structure, an union), \texttt{ret} \textit{must} fail to type-check, preserving the stack at runtime and preventing an undefined behavior.

\subsection{Missing return values (a.k.a. registers not bound before return)}\label{subsec:nstar-common-bs-unboundregs}

Along with checking that we are returning to a valid code-space address, we can also, thanks to the type of the stack, determine if returning from a function preserves the value in registers, and if after returning we have access to return values of a function.
Consider the example given in Listing~\ref{lst:nstar-common-bs-returnvalues}.

When \texttt{ret}urning from the \texttt{example} ``function'', we give access to the values of type \texttt{u64} in the \texttt{\%rax} and \texttt{\%rbx} registers.
Note that if either of those registers were not bound before (not given as parameters, or bound using \texttt{mov}), type-checking \textit{must} fail to prevent undefined behavior when later accessing the ``value'' in either register.
We can easily see that the return context contains \texttt{\%rax: u64} and \texttt{\%rbx: u64}, which means that both registers must have been bound before, and are accessible for reading later one, after the \texttt{call} that went until here.
This gives a safe way of using return values, and guaranteeing that there are indeed return values stored in the target registers.

\begin{listing}[htb]
  \centering
  \begin{minipage}{0.90\textwidth}
    \begin{minted}[]{\nstarlexer}
    example: forall (s: Ts). { %rsp: sptr *{ %rsp: sptr s, %rax: u64, %rbx: u64 } }
      mov 0, %rax
      mov 5, %rbx
      ret
    \end{minted}
  \end{minipage}
  \caption{An example of returning multiple values from a simple function.}
  \label{lst:nstar-common-bs-returnvalues}
\end{listing}

\subsection{Type-checking and scoping problems}\label{subsec:nstar-common-bs-tcscopes}

The type system in N* cannot detect control flow leaks.
One common idiom in assembly languages is the possibility of doing things like in Listing~\ref{lst:nstar-common-bs-labeljumping}.
The idea is pretty simple: a label is just a way of naming a code-space address (or data-space address, but it is not the main concern here) which points to the next instruction after it.
This works in plain assembly languages because of the lack of an advanced type system like the one N* has.

\begin{listing}[htb]
  \centering
  \begin{minipage}{0.90\textwidth}
    \begin{minted}[]{asm}
    f:
      cmp %rax, $0
      je r
    tmp:
      mov $0, %rax
    r:
      ret
    \end{minted}
  \end{minipage}
  \caption{A simple case of jumping through a label (here \texttt{tmp}) in the GNU Assembler.}
  \label{lst:nstar-common-bs-labeljumping}
\end{listing}

In N*, however, because you must specify the branching context of a label, jumping through one cannot be allowed without some sort of scoping notion.
Take the example in Listing~\ref{lst:nstar-common-bs-labeljumping2}.
The instruction \texttt{jmp tmp<s>} seems unneeded (in fact, it can be optimized away), but it really is to ensure type-checking is correct, as per N*'s semantics.

\begin{listing}[htb]
  \centering
  \begin{minipage}{0.90\textwidth}
    \begin{minted}[]{\nstarlexer}
      f: forall (s: Ts). { %rsp: sptr *{ %rsp: sptr s, %rax: u64 }::s, %rax: u64 }
        cmp %rax, 0
        je r<s>
        jmp tmp<s>
      tmp: forall (s: Ts). { %rsp: sptr *{ %rsp: sptr s, %rax: u64 }::s, %rax: u64 }
        mov 0, %rax
        jmp r<s>
      r: forall (s: Ts). { %rsp: sptr *{ %rsp: sptr s, %rax: u64 }::s, %rax: u64 }
        ret
    \end{minted}
  \end{minipage}
  \caption{The same example as Listing~\ref{lst:nstar-common-bs-labeljumping}, but in N*.}
  \label{lst:nstar-common-bs-labeljumping2}
\end{listing}

Trying to remove this instruction makes us question about type-checking: what solution do we have when type-checking the \texttt{tmp} label? (same reasoning can be applied for the \texttt{r} label)
\begin{itemize}
  \item
        One way would be to try to unify \texttt{tmp}'s context type with the current context.
        While this works for this specific example, there are plenty of examples where this would not work, for example trying to type-check \texttt{f} this way (which basically would fail because the current context is empty).

        Also, how would we infer that the \texttt{s} stack type used in \texttt{tmp}'s type is the same as the one used in \texttt{f}'s type?
        Going by name isn't the way, as we might want to do \texttt{jump tmp<sss>} (where \texttt{sss} is bound in \texttt{f}'s context but not \texttt{tmp}'s context).
  \item
        Another way is to introduce scopes, where \texttt{tmp} becomes a ``sub-label'' of \texttt{f}, being allowed to now use the rigid type variable \texttt{s} bound in its parent's context.
        This obviously seems to work, but introduces quite a lot of complexity in the making of the code, for example how do we introduce a new block (indentation-based? with \texttt{\{\}}?), what are the semantics, will the syntax clash with types, etc.

        This however solves the type variable specialization problem, but still leaves the type-checking of child labels unresolved.
\end{itemize}

Branch-checking is therefore used to guarantee that every label is branched to at some point in time, and that the control flow never leaks through a label.

\section{Unsafe operations}\label{sec:nstar-common-unsafe}

\subsection{Dereferencing literal addresses}\label{subsec:nstar-common-unsafe-derefliteraladdr}

\subsection{Pointer offsetting}\label{subsec:nstar-common-unsafe-ptroffset}
